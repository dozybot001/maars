/**
 * Executor Runner Module
 * Handles task execution and real-time state updates via WebSocket
 */

const executorManager = require('./manager');
const verifierManager = require('../verifier/manager');
const dispatcher = require('../dispatcher');
const db = require('../db');

class ExecutorRunner {
  constructor(io) {
    this.io = io;
    this.isRunning = false;
    this.runningTasks = new Set();
    this.completedTasks = new Set();
    this.pendingTasks = new Set();
    this.taskPromises = new Map();
    this.chainCache = [];
    this.taskMap = new Map();
    this.reverseDependencyIndex = new Map();
    this.taskFailureCount = new Map(); // Track failure count for each task (execution + verification failures)
    this.EXECUTION_PASS_PROBABILITY = 0.95; // 95% execution pass probability
    this.VERIFY_PASS_PROBABILITY = 0.95; // 95% verification pass probability
    this.MAX_FAILURES = 3; // Maximum failures before rollback (allows 2 retries, total 3 attempts)
    this.timetableLayout = null; // Cache for timetable layout from generateExecutionMap
  }

  // Start mock execution - only uses cache, not database
  async startMockExecution() {
    if (this.isRunning) {
      throw new Error('Execution is already running');
    }

    // Check if cache is available
    if (!this.chainCache || this.chainCache.length === 0) {
      throw new Error('No execution map cache found. Please generate execution map first.');
    }

    if (!this.timetableLayout) {
      throw new Error('No timetable layout cache found. Please generate execution map first.');
    }

    this.isRunning = true;
    
    try {
      // Reset executor and verifier states
      executorManager.initializeExecutors();
      verifierManager.initializeVerifiers();
      this.broadcastExecutorStates();
      this.broadcastVerifierStates();

      // Use cached timetable layout (already generated by generateExecutionMap)
      const timetableLayout = this.timetableLayout;

      // Reset task statuses in cache to 'undone' for fresh execution
      this.chainCache.forEach(task => {
        task.status = 'undone';
      });

      // Initialize task tracking
      this.runningTasks.clear();
      this.completedTasks.clear();
      this.pendingTasks.clear();
      this.taskPromises.clear();
      this.taskMap.clear();
      this.reverseDependencyIndex.clear();
      this.taskFailureCount.clear();

      this.chainCache.forEach(task => {
        this.taskMap.set(task.id, task);
        this.pendingTasks.add(task.id);
        this.reverseDependencyIndex.set(task.id, []);
      });

      // Build reverse dependency index
      this.chainCache.forEach(task => {
        if (task.dependencies && task.dependencies.length > 0) {
          task.dependencies.forEach(depId => {
            const dependents = this.reverseDependencyIndex.get(depId);
            if (dependents) {
              dependents.push(task.id);
            }
          });
        }
      });

      // Broadcast initial timetable layout
      this.io.emit('timetable-layout', { layout: timetableLayout });

      // Broadcast initial task states
      this.broadcastTaskStates();

      // Start execution
      await this.executeTasks();

    } catch (error) {
      console.error('Error in mock execution:', error);
      this.io.emit('execution-error', { error: error.message });
      throw error;
    } finally {
      this.isRunning = false;
    }
  }

  // Execute tasks
  async executeTasks() {
    // Find initial ready tasks
    const initialReadyTasks = this.chainCache.filter(task =>
      this.areDependenciesSatisfied(task) && this.pendingTasks.has(task.id)
    );

    console.log(`Found ${initialReadyTasks.length} initial ready tasks out of ${this.chainCache.length} total tasks`);

    // Start all initial ready tasks
    initialReadyTasks.forEach(task => {
      const promise = this.executeTask(task).catch(async (error) => {
        console.error(`Error executing task ${task.id}:`, error);
        await this.releaseExecutor(task.id);
        verifierManager.releaseVerifierByTaskId(task.id);
        this.broadcastVerifierStates();
        this.completedTasks.add(task.id);
        this.runningTasks.delete(task.id);
        this.pendingTasks.delete(task.id);
        this.updateTaskStatus(task.id, 'verifying');
        setTimeout(() => {
          this.updateTaskStatus(task.id, 'done');
        }, 300);
        const dependents = this.reverseDependencyIndex.get(task.id) || [];
        this.checkSpecificTasks(dependents.map(id => this.taskMap.get(id)).filter(Boolean));
      });
      this.taskPromises.set(task.id, promise);
    });

    // Polling mechanism to check for pending tasks
    const pollInterval = setInterval(() => {
      const pendingReadyTasks = Array.from(this.pendingTasks).filter(taskId => {
        if (this.runningTasks.has(taskId) || this.completedTasks.has(taskId)) return false;
        const task = this.taskMap.get(taskId);
        return task && this.areDependenciesSatisfied(task);
      });

      if (pendingReadyTasks.length > 0) {
        this.checkSpecificTasks(pendingReadyTasks.map(id => this.taskMap.get(id)).filter(Boolean));
      }

      if (this.completedTasks.size === this.chainCache.length) {
        clearInterval(pollInterval);
      }
    }, 200);

    // Wait for all promises to complete
    const allPromises = Array.from(this.taskPromises.values());
    await Promise.all(allPromises);

    clearInterval(pollInterval);

    // Final check
    let finalCheckCount = 0;
    while (this.completedTasks.size < this.chainCache.length && finalCheckCount < 50) {
      await new Promise(resolve => setTimeout(resolve, 100));
      finalCheckCount++;
      const remainingPendingTasks = Array.from(this.pendingTasks).filter(taskId => {
        if (this.runningTasks.has(taskId) || this.completedTasks.has(taskId)) return false;
        const task = this.taskMap.get(taskId);
        return task && this.areDependenciesSatisfied(task);
      });
      if (remainingPendingTasks.length > 0) {
        this.checkSpecificTasks(remainingPendingTasks.map(id => this.taskMap.get(id)).filter(Boolean));
      }
    }

    console.log(`Final state: ${this.completedTasks.size}/${this.chainCache.length} tasks completed`);
    this.io.emit('execution-complete', {
      completed: this.completedTasks.size,
      total: this.chainCache.length
    });
  }

  // Execute a single task
  async executeTask(task) {
    // Assign executor
    let executorId = null;
    let retryCount = 0;
    const maxRetries = 50;

    while (executorId === null && retryCount < maxRetries) {
      executorId = executorManager.assignTask(task.id);
      if (executorId === null) {
        const waitTime = Math.min(100 + retryCount * 20, 500);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        retryCount++;
        // Broadcast executor states periodically
        if (retryCount % 5 === 0) {
          this.broadcastExecutorStates();
        }
      }
    }

    if (executorId === null) {
      console.error(`Failed to assign executor to task ${task.id} after ${retryCount} retries`);
      this.completedTasks.add(task.id);
      this.runningTasks.delete(task.id);
      this.pendingTasks.delete(task.id);
      this.updateTaskStatus(task.id, 'done');
      const dependents = this.reverseDependencyIndex.get(task.id) || [];
      this.checkSpecificTasks(dependents.map(id => this.taskMap.get(id)).filter(Boolean));
      return;
    }

    // Mark as running
    this.runningTasks.add(task.id);
    this.updateTaskStatus(task.id, 'doing');
    this.broadcastExecutorStates();

    try {
      // Random execution time (500ms to 2000ms)
      const executionTime = 500 + Math.random() * 1500;
      await new Promise(resolve => setTimeout(resolve, executionTime));

      // Check execution result with 95% pass probability
      const executionPassed = Math.random() < this.EXECUTION_PASS_PROBABILITY;
      
      if (!executionPassed) {
        // Execution failed - mark as failed and show light red
        this.updateTaskStatus(task.id, 'execution-failed');
        
        // Mark executor as failed before releasing
        if (executorId !== null) {
          const executor = executorManager.getExecutorById(executorId);
          if (executor) {
            executor.status = 'failed';
            this.broadcastExecutorStates();
            // Wait a bit to show the failed state
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        }
        
        // Get failure count for this task
        const failureCount = this.taskFailureCount.get(task.id) || 0;
        this.taskFailureCount.set(task.id, failureCount + 1);
        
        // Release executor
        await this.releaseExecutor(task.id);
        this.broadcastExecutorStates();
        
        // Wait a bit to ensure the failed state is visible
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        if (failureCount < this.MAX_FAILURES - 1) {
          // Not reached max failures yet - retry
          console.log(`Task ${task.id} execution failed (${failureCount + 1}/${this.MAX_FAILURES}), retrying...`);
          
          // Remove from completed and running sets
          this.runningTasks.delete(task.id);
          this.completedTasks.delete(task.id);
          
          // Re-execute the task
          await this.executeTask(task);
          return;
        } else {
          // Reached max failures - rollback
          console.log(`Task ${task.id} execution failed ${failureCount + 1} times (max ${this.MAX_FAILURES}), rolling back...`);
          
          // Remove from completed and running sets
          this.runningTasks.delete(task.id);
          this.completedTasks.delete(task.id);
          
          // Rollback: mark all dependency tasks as undone
          await this.rollbackTask(task);
          return;
        }
      }

      // Execution passed - continue with verification
      // Release executor immediately after execution
      await this.releaseExecutor(task.id);
      this.broadcastExecutorStates();

      // Mark as verifying and assign verifier
      this.updateTaskStatus(task.id, 'verifying');
      
      // Assign verifier for verification phase
      let verifierId = null;
      let retryCount = 0;
      const maxRetries = 50;

      while (verifierId === null && retryCount < maxRetries) {
        verifierId = verifierManager.assignTask(task.id);
        if (verifierId === null) {
          const waitTime = Math.min(100 + retryCount * 20, 500);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          retryCount++;
          // Broadcast verifier states periodically
          if (retryCount % 5 === 0) {
            this.broadcastVerifierStates();
          }
        }
      }

      if (verifierId === null) {
        console.error(`Failed to assign verifier to task ${task.id} after ${retryCount} retries`);
        // Continue without verifier (verification still happens)
      } else {
        this.broadcastVerifierStates();
      }

      // Random verification time (200ms to 800ms)
      const verificationTime = 200 + Math.random() * 600;
      await new Promise(resolve => setTimeout(resolve, verificationTime));

      // Check verification result with 95% pass probability
      const verificationPassed = Math.random() < this.VERIFY_PASS_PROBABILITY;
      
      // Release verifier after verification completes (only if verification passed)
      if (verificationPassed) {
        if (verifierId !== null) {
          verifierManager.releaseVerifierByTaskId(task.id);
          this.broadcastVerifierStates();
        }
      }
      
      if (!verificationPassed) {
        // Verification failed - mark as failed and show light red
        this.updateTaskStatus(task.id, 'verification-failed');
        
        // Mark verifier as failed before releasing
        if (verifierId !== null) {
          const verifier = verifierManager.getVerifierById(verifierId);
          if (verifier) {
            verifier.status = 'failed';
            this.broadcastVerifierStates();
            // Wait a bit to show the failed state
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        }
        
        // Get failure count for this task (unified counter for execution + verification failures)
        const failureCount = this.taskFailureCount.get(task.id) || 0;
        this.taskFailureCount.set(task.id, failureCount + 1);
        
        // Wait a bit longer to ensure the failed state is visible
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Release verifier before retry or rollback
        if (verifierId !== null) {
          verifierManager.releaseVerifierByTaskId(task.id);
          this.broadcastVerifierStates();
        }
        
        if (failureCount < this.MAX_FAILURES - 1) {
          // Not reached max failures yet - retry
          console.log(`Task ${task.id} verification failed (${failureCount + 1}/${this.MAX_FAILURES}), retrying...`);
          
          // Remove from completed and running sets
          this.runningTasks.delete(task.id);
          this.completedTasks.delete(task.id);
          
          // Re-execute the task
          await this.executeTask(task);
          return;
        } else {
          // Reached max failures - rollback
          console.log(`Task ${task.id} verification failed ${failureCount + 1} times (max ${this.MAX_FAILURES}), rolling back...`);
          
          // Remove from completed and running sets
          this.runningTasks.delete(task.id);
          this.completedTasks.delete(task.id);
          
          // Rollback: mark all dependency tasks as undone
          await this.rollbackTask(task);
          return;
        }
      }

    } catch (executionError) {
      await this.releaseExecutor(task.id);
      verifierManager.releaseVerifierByTaskId(task.id);
      this.broadcastExecutorStates();
      this.broadcastVerifierStates();
      throw executionError;
    }

    // Mark as completed (execution and verification both passed)
    this.runningTasks.delete(task.id);
    this.completedTasks.add(task.id);
    this.pendingTasks.delete(task.id);
    this.updateTaskStatus(task.id, 'done');
    // Reset failure count on success
    this.taskFailureCount.delete(task.id);

    // Check dependents
    const dependents = this.reverseDependencyIndex.get(task.id) || [];
    const candidatesToCheck = new Set(dependents);

    this.chainCache.forEach(t => {
      if (!t.dependencies || t.dependencies.length === 0) {
        if (this.pendingTasks.has(t.id) && !this.runningTasks.has(t.id)) {
          candidatesToCheck.add(t.id);
        }
      }
    });

    this.pendingTasks.forEach(taskId => {
      if (!this.runningTasks.has(taskId) && !this.completedTasks.has(taskId)) {
        const pendingTask = this.taskMap.get(taskId);
        if (pendingTask && this.areDependenciesSatisfied(pendingTask)) {
          candidatesToCheck.add(taskId);
        }
      }
    });

    this.checkSpecificTasks(Array.from(candidatesToCheck).map(id => this.taskMap.get(id)).filter(Boolean));
  }

  // Check specific tasks
  checkSpecificTasks(tasksToCheck) {
    if (!tasksToCheck || tasksToCheck.length === 0) return;

    const readyTasks = tasksToCheck.filter(task => {
      if (!task) return false;
      if (this.completedTasks.has(task.id)) return false;
      if (this.runningTasks.has(task.id)) return false;
      if (!this.pendingTasks.has(task.id)) return false;
      return this.areDependenciesSatisfied(task);
    });

    readyTasks.forEach(task => {
      if (!this.taskPromises.has(task.id)) {
        const promise = this.executeTask(task).catch(async (error) => {
          console.error(`Error executing task ${task.id}:`, error);
          await this.releaseExecutor(task.id);
          verifierManager.releaseVerifierByTaskId(task.id);
          this.broadcastExecutorStates();
          this.broadcastVerifierStates();
          this.completedTasks.add(task.id);
          this.runningTasks.delete(task.id);
          this.pendingTasks.delete(task.id);
          this.updateTaskStatus(task.id, 'verifying');
          setTimeout(() => {
            this.updateTaskStatus(task.id, 'done');
          }, 300);
          const dependents = this.reverseDependencyIndex.get(task.id) || [];
          this.checkSpecificTasks(dependents.map(id => this.taskMap.get(id)).filter(Boolean));
        });
        this.taskPromises.set(task.id, promise);
      }
    });
  }

  // Check if dependencies are satisfied
  areDependenciesSatisfied(task) {
    if (!task.dependencies || task.dependencies.length === 0) {
      return true;
    }
    return task.dependencies.every(depId => this.completedTasks.has(depId));
  }

  // Release executor
  async releaseExecutor(taskId) {
    executorManager.releaseExecutorByTaskId(taskId);
  }

  // Update task status
  updateTaskStatus(taskId, status) {
    const task = this.chainCache.find(t => t.id === taskId);
    if (task) {
      task.status = status;
      this.broadcastTaskStates();
    }
  }

  // Broadcast task states
  broadcastTaskStates() {
    const taskStates = this.chainCache.map(task => ({
      id: task.id,
      status: task.status
    }));
    this.io.emit('task-states-update', { tasks: taskStates });
  }

  // Broadcast executor states
  broadcastExecutorStates() {
    const executors = executorManager.getAllExecutors();
    const stats = executorManager.getExecutorStats();
    this.io.emit('executor-states-update', { executors, stats });
  }

  // Broadcast verifier states
  broadcastVerifierStates() {
    const verifiers = verifierManager.getAllVerifiers();
    const stats = verifierManager.getVerifierStats();
    this.io.emit('verifier-states-update', { verifiers, stats });
  }

  // Rollback task: mark all dependency tasks and their dependents as undone
  // 
  // Example: If task A depends on B, and tasks A and D both depend on B:
  // - When A fails twice, we rollback:
  //   1. B (predecessor of A)
  //   2. A (current task) and D (all tasks that depend on B)
  //
  // This ensures that when B is re-executed, all tasks that depend on B
  // will also be re-executed with the new results from B.
  async rollbackTask(task) {
    const tasksToRollback = new Set();
    
    // Step 1: Add all dependency tasks (predecessors) of the failed task
    // These are the tasks that must be re-executed
    if (task.dependencies && task.dependencies.length > 0) {
      task.dependencies.forEach(depId => {
        tasksToRollback.add(depId);
      });
    }
    
    // Step 2: For each dependency task, find all tasks that depend on it (successors)
    // These tasks also need to be rolled back because they depend on the predecessor
    // that will be re-executed
    task.dependencies.forEach(depId => {
      const dependents = this.reverseDependencyIndex.get(depId) || [];
      dependents.forEach(dependentId => {
        tasksToRollback.add(dependentId);
      });
    });
    
    // Note: The current task (task.id) is already included in tasksToRollback
    // from Step 2, since it's one of the dependents of its dependencies
    
    // Step 3: Mark all tasks to rollback as undone
    tasksToRollback.forEach(taskId => {
      const taskToRollback = this.taskMap.get(taskId);
      if (taskToRollback) {
        // Remove from completed set
        this.completedTasks.delete(taskId);
        // Add back to pending set
        this.pendingTasks.add(taskId);
        // Remove from running set
        this.runningTasks.delete(taskId);
        // Reset status to undone
        this.updateTaskStatus(taskId, 'undone');
        // Reset failure count
        this.taskFailureCount.delete(taskId);
        // Cancel any running promise for this task
        if (this.taskPromises.has(taskId)) {
          this.taskPromises.delete(taskId);
        }
        // Release executor and verifier if assigned
        this.releaseExecutor(taskId);
        verifierManager.releaseVerifierByTaskId(taskId);
      }
    });
    
    // Step 4: Also mark the current task as undone (in case it wasn't already included)
    // This is a safety check, though it should already be in tasksToRollback
    if (!tasksToRollback.has(task.id)) {
      this.completedTasks.delete(task.id);
      this.pendingTasks.add(task.id);
      this.runningTasks.delete(task.id);
      this.updateTaskStatus(task.id, 'undone');
      this.taskFailureCount.delete(task.id);
      if (this.taskPromises.has(task.id)) {
        this.taskPromises.delete(task.id);
      }
    }
    
    // Also reset failure count for current task
    this.taskFailureCount.delete(task.id);
    
    this.broadcastExecutorStates();
    this.broadcastVerifierStates();
    
    // Step 5: Re-check tasks that can now run (e.g., tasks with no dependencies)
    const readyTasks = Array.from(tasksToRollback)
      .map(id => this.taskMap.get(id))
      .filter(t => t && this.areDependenciesSatisfied(t) && this.pendingTasks.has(t.id));
    
    if (readyTasks.length > 0) {
      this.checkSpecificTasks(readyTasks);
    }
  }

  // Set timetable layout cache (called by generateExecutionMap)
  setTimetableLayoutCache(layout) {
    this.timetableLayout = layout;
    
    // Build chain cache from layout
    this.chainCache = [];
    const { grid, isolatedTasks } = layout;

    grid.forEach(row => {
      row.forEach(cell => {
        if (cell && cell.id) {
          this.chainCache.push({
            id: cell.id,
            dependencies: cell.dependencies || [],
            status: cell.status || 'undone'
          });
        }
      });
    });

    if (isolatedTasks) {
      isolatedTasks.forEach(task => {
        if (task && task.id) {
          this.chainCache.push({
            id: task.id,
            dependencies: task.dependencies || [],
            status: task.status || 'undone'
          });
        }
      });
    }
  }

  // Stop execution
  stop() {
    this.isRunning = false;
    // Cancel all pending tasks
    this.taskPromises.forEach((promise, taskId) => {
      this.releaseExecutor(taskId);
      verifierManager.releaseVerifierByTaskId(taskId);
    });
    this.taskPromises.clear();
    this.broadcastExecutorStates();
    this.broadcastVerifierStates();
  }
}

module.exports = ExecutorRunner;
