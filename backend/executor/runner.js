/**
 * Executor Runner Module
 * Handles task execution and real-time state updates via WebSocket
 */

const { executor: executorManager, verifier: verifierManager } = require('../workers');

class ExecutorRunner {
  constructor(io) {
    this.io = io;
    this.isRunning = false;
    this.runningTasks = new Set();
    this.completedTasks = new Set();
    this.pendingTasks = new Set();
    this.taskPromises = new Map();
    this.chainCache = [];
    this.taskMap = new Map();
    this.reverseDependencyIndex = new Map();
    this.taskFailureCount = new Map(); // Track failure count for each task (execution + verification failures)
    this.EXECUTION_PASS_PROBABILITY = 0.95;
    this.VERIFY_PASS_PROBABILITY = 0.95;
    this.MAX_FAILURES = 3; // Maximum failures before rollback (allows 2 retries, total 3 attempts)
    this.timetableLayout = null; // Cache for timetable layout from generateExecutionMap
  }

  // Start mock execution - only uses cache, not database
  async startMockExecution() {
    if (this.isRunning) {
      throw new Error('Execution is already running');
    }

    // Check if cache is available
    if (!this.chainCache || this.chainCache.length === 0) {
      throw new Error('No execution map cache found. Please generate execution map first.');
    }

    if (!this.timetableLayout) {
      throw new Error('No timetable layout cache found. Please generate execution map first.');
    }

    this.isRunning = true;
    
    try {
      // Reset executor and verifier states
      executorManager.initializeExecutors();
      verifierManager.initializeVerifiers();
      this.broadcastExecutorStates();
      this.broadcastVerifierStates();

      // Use cached timetable layout (already generated by generateExecutionMap)
      const timetableLayout = this.timetableLayout;

      // Reset task statuses in cache to 'undone' for fresh execution
      this.chainCache.forEach(task => {
        task.status = 'undone';
      });

      // Initialize task tracking
      this.runningTasks.clear();
      this.completedTasks.clear();
      this.pendingTasks.clear();
      this.taskPromises.clear();
      this.taskMap.clear();
      this.reverseDependencyIndex.clear();
      this.taskFailureCount.clear();

      this.chainCache.forEach(task => {
        this.taskMap.set(task.task_id, task);
        this.pendingTasks.add(task.task_id);
        this.reverseDependencyIndex.set(task.task_id, []);
      });

      // Build reverse dependency index
      this.chainCache.forEach(task => {
        if (task.dependencies && task.dependencies.length > 0) {
          task.dependencies.forEach(depId => {
            const dependents = this.reverseDependencyIndex.get(depId);
            if (dependents) {
              dependents.push(task.task_id);
            }
          });
        }
      });

      // Broadcast initial timetable layout
      this.io.emit('timetable-layout', { layout: timetableLayout });

      // Broadcast initial task states
      this.broadcastTaskStates();

      // Start execution
      await this.executeTasks();

    } catch (error) {
      console.error('Error in mock execution:', error);
      this.io.emit('execution-error', { error: error.message });
      throw error;
    } finally {
      this.isRunning = false;
      // Release all executors/verifiers (including any stuck in failed state)
      executorManager.initializeExecutors();
      verifierManager.initializeVerifiers();
      this.broadcastExecutorStates();
      this.broadcastVerifierStates();
    }
  }

  // Get tasks that are pending and ready to run (dependencies satisfied)
  getPendingReadyTasks() {
    return Array.from(this.pendingTasks)
      .filter(taskId => {
        if (this.runningTasks.has(taskId) || this.completedTasks.has(taskId)) return false;
        const task = this.taskMap.get(taskId);
        return task && this.areDependenciesSatisfied(task);
      })
      .map(id => this.taskMap.get(id))
      .filter(Boolean);
  }

  // Execute tasks
  async executeTasks() {
    // Find initial ready tasks
    const initialReadyTasks = this.getPendingReadyTasks();

    console.log(`Found ${initialReadyTasks.length} initial ready tasks out of ${this.chainCache.length} total tasks`);

    // Start all initial ready tasks
    initialReadyTasks.forEach(task => {
      const promise = this.executeTask(task).catch(error => this.handleTaskError(task, error));
      this.taskPromises.set(task.task_id, promise);
    });

    // Polling mechanism to check for pending tasks
    const pollInterval = setInterval(() => {
      const pendingReadyTasks = this.getPendingReadyTasks();
      if (pendingReadyTasks.length > 0) {
        this.checkSpecificTasks(pendingReadyTasks);
      }
    }, 200);

    // Wait for all tasks to complete (including retries)
    // Keep checking until all tasks are completed, no tasks are running, and no pending tasks can run
    while (true) {
      // Check if all tasks are completed
      if (this.completedTasks.size === this.chainCache.length) {
        // Double check: ensure no tasks are still running
        if (this.runningTasks.size === 0) {
          // Wait a bit more to ensure all promises have resolved
          await new Promise(resolve => setTimeout(resolve, 300));
          // Final verification: check again after waiting
          if (this.completedTasks.size === this.chainCache.length && this.runningTasks.size === 0) {
            break;
          }
        }
      }
      
      // Check for any pending tasks that can run
      const pendingReadyTasks = this.getPendingReadyTasks();
      if (pendingReadyTasks.length > 0) {
        this.checkSpecificTasks(pendingReadyTasks);
      }
      
      // Wait before next check
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    clearInterval(pollInterval);

    console.log(`Final state: ${this.completedTasks.size}/${this.chainCache.length} tasks completed`);
    this.io.emit('execution-complete', {
      completed: this.completedTasks.size,
      total: this.chainCache.length
    });
  }

  // Execute a single task
  async executeTask(task) {
    // Assign executor
    let executorId = null;
    let retryCount = 0;
    const maxRetries = 50;

    while (executorId === null && retryCount < maxRetries) {
      executorId = executorManager.assignTask(task.task_id);
      if (executorId === null) {
        const waitTime = Math.min(100 + retryCount * 20, 500);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        retryCount++;
        // Broadcast executor states periodically
        if (retryCount % 5 === 0) {
          this.broadcastExecutorStates();
        }
      }
    }

    if (executorId === null) {
      console.error(`Failed to assign executor to task ${task.task_id} after ${retryCount} retries`);
      this.completedTasks.add(task.task_id);
      this.runningTasks.delete(task.task_id);
      this.pendingTasks.delete(task.task_id);
      this.updateTaskStatus(task.task_id, 'done');
      const dependents = this.reverseDependencyIndex.get(task.task_id) || [];
      this.checkSpecificTasks(dependents.map(id => this.taskMap.get(id)).filter(Boolean));
      return;
    }

    // Mark as running
    this.runningTasks.add(task.task_id);
    this.updateTaskStatus(task.task_id, 'doing');
    this.broadcastExecutorStates();

    try {
      // Random execution time (500ms to 2000ms)
      const executionTime = 500 + Math.random() * 1500;
      await new Promise(resolve => setTimeout(resolve, executionTime));

      // Check execution result with 95% pass probability
      const executionPassed = Math.random() < this.EXECUTION_PASS_PROBABILITY;
      
      if (!executionPassed) {
        // Execution failed - mark as failed and show light red
        this.updateTaskStatus(task.task_id, 'execution-failed');
        
        // Mark executor as failed before releasing
        if (executorId !== null) {
          const executor = executorManager.getExecutorById(executorId);
          if (executor) {
            executor.status = 'failed';
            this.broadcastExecutorStates();
            // Wait a bit to show the failed state
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        }
        
        // Get failure count for this task
        const failureCount = this.taskFailureCount.get(task.task_id) || 0;
        this.taskFailureCount.set(task.task_id, failureCount + 1);
        
        // Release executor
        await this.releaseExecutor(task.task_id);
        this.broadcastExecutorStates();
        
        // Wait a bit to ensure the failed state is visible
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        if (failureCount < this.MAX_FAILURES - 1) {
          // Not reached max failures yet - retry
          console.log(`Task ${task.task_id} execution failed (${failureCount + 1}/${this.MAX_FAILURES}), retrying...`);
          
          // Remove from completed and running sets
          this.runningTasks.delete(task.task_id);
          this.completedTasks.delete(task.task_id);
          
          // Re-execute the task
          await this.executeTask(task);
          return;
        } else {
          // Reached max failures - rollback
          console.log(`Task ${task.task_id} execution failed ${failureCount + 1} times (max ${this.MAX_FAILURES}), rolling back...`);
          
          // Remove from completed and running sets
          this.runningTasks.delete(task.task_id);
          this.completedTasks.delete(task.task_id);
          
          // Rollback: mark all dependency tasks as undone
          await this.rollbackTask(task);
          return;
        }
      }

      // Execution passed - continue with verification
      // Release executor immediately after execution
      await this.releaseExecutor(task.task_id);
      this.broadcastExecutorStates();

      // Mark as verifying and assign verifier
      this.updateTaskStatus(task.task_id, 'verifying');
      
      // Assign verifier for verification phase
      let verifierId = null;
      let retryCount = 0;
      const maxRetries = 50;

      while (verifierId === null && retryCount < maxRetries) {
        verifierId = verifierManager.assignTask(task.task_id);
        if (verifierId === null) {
          const waitTime = Math.min(100 + retryCount * 20, 500);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          retryCount++;
          // Broadcast verifier states periodically
          if (retryCount % 5 === 0) {
            this.broadcastVerifierStates();
          }
        }
      }

      if (verifierId === null) {
        console.error(`Failed to assign verifier to task ${task.task_id} after ${retryCount} retries`);
        // Continue without verifier (verification still happens)
      } else {
        this.broadcastVerifierStates();
      }

      // Random verification time (200ms to 800ms)
      const verificationTime = 200 + Math.random() * 600;
      await new Promise(resolve => setTimeout(resolve, verificationTime));

      // Check verification result with 95% pass probability
      const verificationPassed = Math.random() < this.VERIFY_PASS_PROBABILITY;
      
      // Release verifier after verification completes (only if verification passed)
      if (verificationPassed) {
        if (verifierId !== null) {
          verifierManager.releaseVerifierByTaskId(task.task_id);
          this.broadcastVerifierStates();
        }
      }
      
      if (!verificationPassed) {
        // Verification failed - mark as failed and show light red
        this.updateTaskStatus(task.task_id, 'verification-failed');
        
        // Mark verifier as failed before releasing
        if (verifierId !== null) {
          const verifier = verifierManager.getVerifierById(verifierId);
          if (verifier) {
            verifier.status = 'failed';
            this.broadcastVerifierStates();
            // Wait a bit to show the failed state
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        }
        
        // Get failure count for this task (unified counter for execution + verification failures)
        const failureCount = this.taskFailureCount.get(task.task_id) || 0;
        this.taskFailureCount.set(task.task_id, failureCount + 1);
        
        // Wait a bit longer to ensure the failed state is visible
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Release verifier before retry or rollback
        if (verifierId !== null) {
          verifierManager.releaseVerifierByTaskId(task.task_id);
          this.broadcastVerifierStates();
        }
        
        if (failureCount < this.MAX_FAILURES - 1) {
          // Not reached max failures yet - retry
          console.log(`Task ${task.task_id} verification failed (${failureCount + 1}/${this.MAX_FAILURES}), retrying...`);
          
          // Remove from completed and running sets
          this.runningTasks.delete(task.task_id);
          this.completedTasks.delete(task.task_id);
          
          // Re-execute the task
          await this.executeTask(task);
          return;
        } else {
          // Reached max failures - rollback
          console.log(`Task ${task.task_id} verification failed ${failureCount + 1} times (max ${this.MAX_FAILURES}), rolling back...`);
          
          // Remove from completed and running sets
          this.runningTasks.delete(task.task_id);
          this.completedTasks.delete(task.task_id);
          
          // Rollback: mark all dependency tasks as undone
          await this.rollbackTask(task);
          return;
        }
      }

    } catch (executionError) {
      await this.releaseExecutor(task.task_id);
      verifierManager.releaseVerifierByTaskId(task.task_id);
      this.broadcastExecutorStates();
      this.broadcastVerifierStates();
      throw executionError;
    }

    // Mark as completed (execution and verification both passed)
    this.runningTasks.delete(task.task_id);
    this.completedTasks.add(task.task_id);
    this.pendingTasks.delete(task.task_id);
    this.updateTaskStatus(task.task_id, 'done');
    // Reset failure count on success
    this.taskFailureCount.delete(task.task_id);

    // Check dependents
    const dependents = this.reverseDependencyIndex.get(task.task_id) || [];
    const candidatesToCheck = new Set(dependents);

    this.chainCache.forEach(t => {
      if (!t.dependencies || t.dependencies.length === 0) {
        if (this.pendingTasks.has(t.task_id) && !this.runningTasks.has(t.task_id)) {
          candidatesToCheck.add(t.task_id);
        }
      }
    });

    this.pendingTasks.forEach(taskId => {
      if (!this.runningTasks.has(taskId) && !this.completedTasks.has(taskId)) {
        const pendingTask = this.taskMap.get(taskId);
        if (pendingTask && this.areDependenciesSatisfied(pendingTask)) {
          candidatesToCheck.add(taskId);
        }
      }
    });

    this.checkSpecificTasks(Array.from(candidatesToCheck).map(id => this.taskMap.get(id)).filter(Boolean));
  }

  // Check specific tasks
  checkSpecificTasks(tasksToCheck) {
    if (!tasksToCheck || tasksToCheck.length === 0) return;

    const readyTasks = tasksToCheck.filter(task => {
      if (!task) return false;
      if (this.completedTasks.has(task.task_id)) return false;
      if (this.runningTasks.has(task.task_id)) return false;
      if (!this.pendingTasks.has(task.task_id)) return false;
      return this.areDependenciesSatisfied(task);
    });

    readyTasks.forEach(task => {
      if (!this.taskPromises.has(task.task_id)) {
        const promise = this.executeTask(task).catch(error => this.handleTaskError(task, error));
        this.taskPromises.set(task.task_id, promise);
      }
    });
  }

  // Handle task execution error (release resources, mark done, trigger dependents)
  async handleTaskError(task, error) {
    console.error(`Error executing task ${task.task_id}:`, error);
    await this.releaseExecutor(task.task_id);
    verifierManager.releaseVerifierByTaskId(task.task_id);
    this.broadcastExecutorStates();
    this.broadcastVerifierStates();
    this.completedTasks.add(task.task_id);
    this.runningTasks.delete(task.task_id);
    this.pendingTasks.delete(task.task_id);
    this.updateTaskStatus(task.task_id, 'verifying');
    setTimeout(() => this.updateTaskStatus(task.task_id, 'done'), 300);
    const dependents = this.reverseDependencyIndex.get(task.task_id) || [];
    this.checkSpecificTasks(dependents.map(id => this.taskMap.get(id)).filter(Boolean));
  }

  // Check if dependencies are satisfied
  areDependenciesSatisfied(task) {
    if (!task.dependencies || task.dependencies.length === 0) {
      return true;
    }
    return task.dependencies.every(depId => this.completedTasks.has(depId));
  }

  // Release executor
  async releaseExecutor(taskId) {
    executorManager.releaseExecutorByTaskId(taskId);
  }

  // Update task status
  updateTaskStatus(taskId, status) {
    const task = this.chainCache.find(t => t.task_id === taskId);
    if (task) {
      task.status = status;
      this.broadcastTaskStates();
    }
  }

  // Broadcast task states
  broadcastTaskStates() {
    const taskStates = this.chainCache.map(task => ({
      task_id: task.task_id,
      status: task.status
    }));
    this.io.emit('task-states-update', { tasks: taskStates });
  }

  // Broadcast executor states
  broadcastExecutorStates() {
    const executors = executorManager.getAllExecutors();
    const stats = executorManager.getExecutorStats();
    this.io.emit('executor-states-update', { executors, stats });
  }

  // Broadcast verifier states
  broadcastVerifierStates() {
    const verifiers = verifierManager.getAllVerifiers();
    const stats = verifierManager.getVerifierStats();
    this.io.emit('verifier-states-update', { verifiers, stats });
  }

  // Rollback task: mark all dependency tasks and their dependents as undone
  // 
  // Rollback logic:
  // 1. The failed task itself -> undone
  // 2. All dependency tasks (predecessors) of the failed task -> undone
  // 3. All downstream tasks (successors) of the dependency tasks -> undone (recursively)
  //
  // Example: Task dependency chain: B -> C -> D
  //          If C fails and triggers rollback:
  //          - C (failed task) -> undone
  //          - B (dependency of C) -> undone
  //          - D (downstream of C, which depends on B) -> undone
  //          - All other tasks that depend on B -> undone
  async rollbackTask(task) {
    const tasksToRollback = new Set();
    
    // Step 1: Add the failed task itself
    tasksToRollback.add(task.task_id);
    
    // Step 2: Add all dependency tasks (predecessors) of the failed task
    // These are the tasks that must be re-executed
    if (task.dependencies && task.dependencies.length > 0) {
      task.dependencies.forEach(depId => {
        tasksToRollback.add(depId);
      });
    }
    
    // Step 3: Recursively find all downstream tasks (successors) of dependency tasks
    // This includes:
    // - All tasks that directly depend on the dependency tasks
    // - All tasks that depend on those tasks (recursively)
    const visited = new Set();
    const findDownstreamTasks = (taskId) => {
      if (visited.has(taskId)) {
        return;
      }
      visited.add(taskId);
      
      const dependents = this.reverseDependencyIndex.get(taskId) || [];
      dependents.forEach(dependentId => {
        if (!tasksToRollback.has(dependentId)) {
          tasksToRollback.add(dependentId);
          // Recursively find downstream tasks of this dependent
          findDownstreamTasks(dependentId);
        }
      });
    };
    
    // Find all downstream tasks for each dependency task
    if (task.dependencies && task.dependencies.length > 0) {
      task.dependencies.forEach(depId => {
        findDownstreamTasks(depId);
      });
    }
    
    // Step 4: Mark all tasks to rollback as undone
    tasksToRollback.forEach(taskId => {
      const taskToRollback = this.taskMap.get(taskId);
      if (taskToRollback) {
        // Remove from completed set
        this.completedTasks.delete(taskId);
        // Add back to pending set
        this.pendingTasks.add(taskId);
        // Remove from running set
        this.runningTasks.delete(taskId);
        // Reset status to undone
        this.updateTaskStatus(taskId, 'undone');
        // Reset failure count
        this.taskFailureCount.delete(taskId);
        // Cancel any running promise for this task
        if (this.taskPromises.has(taskId)) {
          this.taskPromises.delete(taskId);
        }
        // Release executor and verifier if assigned
        this.releaseExecutor(taskId);
        verifierManager.releaseVerifierByTaskId(taskId);
      }
    });
    
    this.broadcastExecutorStates();
    this.broadcastVerifierStates();
    
    // Step 5: Re-check tasks that can now run (e.g., tasks with no dependencies)
    const readyTasks = Array.from(tasksToRollback)
      .map(id => this.taskMap.get(id))
      .filter(t => t && this.areDependenciesSatisfied(t) && this.pendingTasks.has(t.task_id));
    
    if (readyTasks.length > 0) {
      this.checkSpecificTasks(readyTasks);
    }
  }

  // Set timetable layout cache (called by generateExecutionMap)
  setTimetableLayoutCache(layout) {
    this.timetableLayout = layout;
    
    // Build chain cache from layout
    this.chainCache = [];
    const { grid, isolatedTasks } = layout;

    grid.forEach(row => {
      row.forEach(cell => {
        if (cell && cell.task_id) {
          this.chainCache.push({
            task_id: cell.task_id,
            dependencies: cell.dependencies || [],
            status: cell.status || 'undone'
          });
        }
      });
    });

    if (isolatedTasks) {
      isolatedTasks.forEach(task => {
        if (task && task.task_id) {
          this.chainCache.push({
            task_id: task.task_id,
            dependencies: task.dependencies || [],
            status: task.status || 'undone'
          });
        }
      });
    }
  }

  // Stop execution
  stop() {
    this.isRunning = false;
    // Cancel all pending tasks
    this.taskPromises.forEach((promise, taskId) => {
      this.releaseExecutor(taskId);
      verifierManager.releaseVerifierByTaskId(taskId);
    });
    this.taskPromises.clear();
    this.broadcastExecutorStates();
    this.broadcastVerifierStates();
  }
}

module.exports = ExecutorRunner;
